import pylas
import rasterio
from rasterio.crs import CRS
from rasterio.transform import Affine
import numpy as np
import earthpy.spatial as es
from scipy.interpolate import griddata
import scipy
from matplotlib.cbook import get_sample_data
from matplotlib.colors import LightSource
import matplotlib.pyplot as plt

# Import input LiDAR data
inFile = pylas.read('/home/kianicka/study/LiDAR/data/MracnoBodovDMR5.0_LOT7_Trencin/Cropped_out.las')
new_file = pylas.create(point_format_id=inFile.header.point_format_id, file_version=inFile.header.version)
new_file.points = inFile.points[inFile.classification == 3]

new_file.write('/home/kianicka/study/LiDAR/data/MracnoBodovDMR5.0_LOT7_Trencin/Cropped_out_ground.las')

# Count total point in point cloud
print('The total point is:', inFile.header.point_count)

# List of available dimensions in the file
print('Dimensions:', inFile.point_format.dimension_names)

# Access VLRs
VLRList = inFile.vlrs
print(VLRList)

newFileIn = pylas.read('/home/kianicka/study/LiDAR/data/MracnoBodovDMR5.0_LOT7_Trencin/Cropped_out_ground.las')
# Count total point in point cloud
print('The total point is:', newFileIn.header.point_count)

# List of available dimensions in the file
print('Dimensions:', newFileIn.point_format.dimension_names)


# Get spatial reference system from VLRs
# VLRList.get('GeoAsciiParamsVlr')[0] -- this does not work for my LAS file, generated by QGIS

# Assign point list
points = list(zip(newFileIn.x, newFileIn.y))

# Assign elevation variable
elevation = newFileIn.z

# Assign grid resolution in meter
resolution = 0.2

# Create coord ranges over the desired raster extension
xRange = np.arange(newFileIn.x.min(), newFileIn.x.max() + resolution, resolution)
yRange = np.arange(newFileIn.y.min(), newFileIn.y.max() + resolution, resolution)

# Create arrays of x,y over the raster extension
gridX, gridY = np.meshgrid(xRange, yRange)

# Interpolate over the grid
dem = griddata(points, elevation, (gridX, gridY), method='cubic')

# Chekck the shape of dem
print(dem.shape)

# Create figure
fig = plt.figure(figsize=[40, 40])

# Plot dem
plt.imshow(dem, cmap='gist_earth')

# Customize plot
plt.colorbar(label='meter')
plt.title('Digital Elevation Model', fontweight='bold')
plt.xlabel('width')
plt.ylabel('height')

# Show plot
plt.show()

# Create and plot the hillshade with earthpy
hillshade = es.hillshade(dem, azimuth=30, altitude=30)

# Create figure
fig = plt.figure(figsize=[40, 40])

# Plot dem
plt.imshow(hillshade, cmap='Greys')

# Customize plot
plt.colorbar(label='Hillshade')
plt.title('Hillshade, altitude 30', fontweight='bold')
plt.xlabel('width')
plt.ylabel('height')

# Show plot
plt.show()


# Set coordinate reference system
crs = CRS.from_epsg(3046)

print(crs.data)

# Define transform array
transform = Affine.translation(gridX[0][0]-resolution/2, gridY[0][0]-resolution/2)*Affine.scale(resolution,resolution)
print(transform)

# Register metadata
out_image = rasterio.open('/home/kianicka/study/LiDAR/data/MracnoBodovDMR5.0_LOT7_Trencin/Cropped_out_dem.tif',
                                'w',
                                driver = 'GTiff',
                                height = dem.shape[0],
                                width = dem.shape[1],
                                count = 1,
                                dtype = dem.dtype,
                                crs = crs,
                                transform = transform,
                                )

# Write image
out_image.write(dem,1)
out_image.close()
